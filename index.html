<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 <title>3D Robot Minesweeper (2-Player)</title>
 <!--
     This application is a 3D Minesweeper game built with Three.js.
     - You control a robot on a 3D grid.
     - You can select between keyboard/mouse or touch controls.
     - NEW: Added 2-Player local split-screen mode for keyboard.
     - NEW: Players can select names and colors.
     - NEW: Split-screen rendering for 'follow' camera, shared for 'topDown'.
     - The game logic implements classic Minesweeper rules.
     - Textures for the tiles (numbers, flags, mines) are dynamically generated using HTML Canvas.
     - Level colors and background scenes are procedurally generated for each level.
 -->
 <script src="https://cdn.tailwindcss.com"></script>
 <style>
     body {
         font-family: 'Inter', sans-serif;
         margin: 0;
         padding: 0;
         background-color: #000;
         color: white;
         overflow: hidden; /* Prevent scrolling */
     }
     /* Main 3D container */
     #container {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         cursor: pointer;
     }
     /* Loading screen */
     #loader {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background: rgba(0, 0, 0, 0.8);
         display: flex;
         justify-content: center;
         align-items: center;
         z-index: 100;
         flex-direction: column;
         gap: 1rem;
     }
     /* Base Modal Style */
     .modal-backdrop {
         position: fixed;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         background: rgba(0, 0, 0, 0.9);
         display: flex;
         justify-content: center;
         align-items: center;
         z-index: 90;
         backdrop-filter: blur(10px);
     }
     .modal-content {
         background: rgba(255, 255, 255, 0.1);
         padding: 2.5rem;
         border-radius: 0.5rem;
         box-shadow: 0 10px 25px rgba(0,0,0,0.5);
         text-align: center;
     }
     .modal-btn {
         padding: 1rem 2rem;
         border-radius: 0.5rem;
         font-size: 1.125rem;
         font-weight: 600;
         transition: all 0.2s ease;
         border: none;
         cursor: pointer;
     }
     .modal-btn-primary {
         background-color: #2563EB; /* blue-600 */
         color: white;
     }
     .modal-btn-primary:hover {
         background-color: #1D4ED8; /* blue-700 */
     }
     .modal-btn-secondary {
         background-color: #4B5563; /* gray-600 */
         color: white;
     }
     .modal-btn-secondary:hover {
         background-color: #374151; /* gray-700 */
     }

     /* Player Setup Modal */
     #player-setup-modal {
         display: none; /* Hidden by default */
     }
     .player-setup-grid {
         display: grid;
         grid-template-columns: 1fr;
         gap: 1.5rem;
         margin-top: 1.5rem;
         margin-bottom: 2rem;
     }
     @media (min-width: 640px) {
         .player-setup-grid {
             grid-template-columns: 1fr 1fr;
             gap: 2.5rem;
         }
     }
     .player-column {
         display: flex;
         flex-direction: column;
         gap: 1rem;
         padding: 1.5rem;
         background: rgba(0,0,0,0.2);
         border-radius: 0.5rem;
     }
     .player-column label {
         font-weight: 600;
         font-size: 0.875rem;
         text-align: left;
         color: rgba(255,255,255,0.7);
     }
     .player-column input, .player-column select {
         width: 100%;
         padding: 0.5rem 0.75rem;
         border-radius: 0.375rem;
         background: rgba(0,0,0,0.4);
         border: 1px solid rgba(255,255,255,0.3);
         color: white;
         font-size: 1rem;
     }
     .player-column select option {
         background: #333;
         color: white;
     }

     /* Touch Controls Container */
     #touch-controls {
         position: fixed;
         bottom: 0;
         left: 0;
         width: 100%;
         height: 100%;
         z-index: 50;
         pointer-events: none;
         display: none;
     }
     /* Joystick */
     #joystick-area {
         position: absolute;
         bottom: 5vw;
         left: 5vw;
         width: 30vw;
         height: 30vw;
         max-width: 150px;
         max-height: 150px;
         background: rgba(255, 255, 255, 0.1);
         border-radius: 50%;
         pointer-events: auto;
     }
     #joystick-thumb {
         position: absolute;
         top: 50%;
         left: 50%;
         width: 12vw;
         height: 12vw;
         max-width: 60px;
         max-height: 60px;
         background: rgba(255, 255, 255, 0.5);
         border-radius: 50%;
         transform: translate(-50%, -50%);
         transition: transform 0.1s ease-out;
     }
     /* Action Buttons */
     #action-buttons {
         position: absolute;
         bottom: 5vw;
         right: 5vw;
         display: grid;
         grid-template-columns: 1fr 1fr;
         grid-template-rows: 1fr 1fr 1fr;
         gap: 2vw;
         pointer-events: auto;
     }
     .action-btn {
         width: 15vw;
         height: 15vw;
         max-width: 70px;
         max-height: 70px;
         background: rgba(255, 255, 255, 0.2);
         border: 2px solid rgba(255, 255, 255, 0.3);
         border-radius: 50%;
         display: flex;
         justify-content: center;
         align-items: center;
         font-size: 3vw;
         font-weight: bold;
         color: white;
         user-select: none;
         text-align: center;
         line-height: 1.2;
     }
     @media (min-width: 640px) {
         .action-btn { font-size: 16px; }
     }
     #jump-btn { grid-column: 2 / 3; grid-row: 1 / 2; }
     #reveal-btn { grid-column: 1 / 2; grid-row: 1 / 2; }
     #flag-btn { grid-column: 1 / 2; grid-row: 2 / 3; }
     #crouch-btn { grid-column: 2 / 3; grid-row: 2 / 3; }
  
     /* Top UI */
     #left-ui-container {
         position: absolute;
         top: 10px;
         left: 10px;
         z-index: 20;
         display: flex;
         flex-direction: column;
         gap: 8px;
         align-items: flex-start;
     }
     #info {
         color: white;
         background: rgba(0,0,0,0.5);
         padding: 8px 12px;
         font-size: 0.9rem;
         border-radius: 8px;
         max-width: calc(100vw - 200px);
     }
     #game-ui {
         position: absolute;
         top: 10px;
         right: 10px;
         z-index: 20;
         color: white;
         background: rgba(0,0,0,0.5);
         padding: 8px 12px;
         font-size: 0.9rem;
         border-radius: 8px;
         text-align: right;
     }
     #game-status {
         font-weight: bold;
         font-size: 1.1rem;
         min-height: 1.5rem;
     }
     #ui-buttons {
         display: flex;
         flex-direction: row;
         gap: 8px;
     }
     .ui-btn {
         padding: 6px 10px;
         background: rgba(255, 255, 255, 0.2);
         border: 2px solid rgba(255, 255, 255, 0.3);
         border-radius: 8px;
         color: white;
         font-weight: 600;
         cursor: pointer;
         font-size: 0.9rem;
     }
     .ui-btn:hover {
         background: rgba(255, 255, 255, 0.3);
     }
     #mouse-lock-info {
         position: absolute;
         top: 50%;
         left: 50%;
         transform: translate(-50%, -50%);
         background: rgba(0,0,0,0.7);
         padding: 20px 40px;
         border-radius: 10px;
         font-size: 1.2rem;
         font-weight: 600;
         z-index: 80;
         display: none;
     }
     
     /* Zoom controls */
     #zoom-controls {
         position: fixed;
         bottom: 10px;
         left: 10px;
         z-index: 60;
         display: none;
         flex-direction: column;
         gap: 8px;
         pointer-events: auto;
     }
     .zoom-btn {
         width: 44px;
         height: 44px;
         background: rgba(255, 255, 255, 0.2);
         border: 2px solid rgba(255, 255, 255, 0.3);
         border-radius: 50%;
         color: white;
         font-weight: bold;
         font-size: 24px;
         line-height: 40px;
         text-align: center;
         cursor: pointer;
         user-select: none;
     }
     .zoom-btn:hover {
         background: rgba(255, 255, 255, 0.3);
     }

     /* Player Name Tags (for 3D space) */
     .player-tag {
        position: absolute;
        z-index: 10;
        background: rgba(0, 0, 0, 0.5);
        color: white;
        padding: 2px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        pointer-events: none;
        transform: translateX(-50%); /* Center horizontally */
        white-space: nowrap;
        display: none; /* Hidden by default */
     }
 </style>
</head>
<body>
 <!-- 3D Scene Container -->
 <div id="container"></div>

 <!-- Player Name Tags -->
 <div id="p1-tag" class="player-tag">Player 1</div>
 <div id="p2-tag" class="player-tag">Player 2</div>


 <!-- Left UI Container -->
 <div id="left-ui-container">
     <div id="info">
         <b>P1:</b> (<b>WASD</b>) Move | (<b>E</b>) Reveal | (<b>R/F</b>) Flag | (<b>Space</b>) Jump<br>
         <b>P2:</b> (<b>Arrows</b>) Move | (<b>;</b>) Reveal | (<b>'</b>) Flag | (<b>Enter</b>) Jump
     </div>
     <div id="ui-buttons">
         <button id="camera-btn" class="ui-btn">Switch Camera</button>
         <button id="new-game-btn" class="ui-btn">New Game (Lvl 1)</button>
     </div>
     <div id="level-select-container" class="flex items-center gap-2">
         <label for="level-input" class="text-sm font-medium">Go to Level:</label>
         <input type="number" id="level-input" min="1" max="100" class="w-16 p-1 rounded bg-black/50 text-white border border-white/30 text-center" value="1">
         <button id="level-go-btn" class="ui-btn px-3 py-1">Go</button>
     </div>
 </div>

 <!-- Game Status UI -->
 <div id="game-ui">
     <div class="font-bold text-lg tracking-wide text-white/90">
         Level: <span id="level-text" class="text-white">1</span>
     </div>
     <div class="font-bold text-lg tracking-wide text-white/90 mt-1">
         Mines Left: <span id="mines-text" class="text-white">0</span>
     </div>
     <div id="game-status" class="mt-2"></div>
 </div>

 <!-- Loading Screen -->
 <div id="loader">
     <div class="text-2xl font-bold animate-pulse">Loading...</div>
     <div id="loader-subtext" class="text-lg">Loading 3D Models...</div>
 </div>

 <!-- Input Selection Modal -->
 <div id="input-modal" class="modal-backdrop">
     <div class="modal-content">
         <h2 class="text-3xl font-bold mb-6">Select Input Mode</h2>
         <p class="mb-8">Is this a touch screen device?</p>
         <div class="flex justify-center gap-6">
             <button id="touch-btn" class="modal-btn modal-btn-primary">
                 Yes (Touch)
             </button>
             <button id="keyboard-btn" class="modal-btn modal-btn-secondary">
                 No (Keyboard)
             </button>
         </div>
     </div>
 </div>

 <!-- NEW: Game Mode Selection Modal -->
 <div id="game-mode-modal" class="modal-backdrop" style="display: none;">
     <div class="modal-content">
         <h2 class="text-3xl font-bold mb-6">Select Game Mode</h2>
         <div class="flex justify-center gap-6">
             <button id="single-player-btn" class="modal-btn modal-btn-primary">
                 1 Player
             </button>
             <button id="multi-player-btn" class="modal-btn modal-btn-primary">
                 2 Player (Local)
             </button>
         </div>
         <button id="game-mode-back-btn" class="modal-btn modal-btn-secondary mt-6">Back</button>
     </div>
 </div>

 <!-- NEW: Player Setup Modal -->
 <div id="player-setup-modal" class="modal-backdrop">
     <div class="modal-content w-11/12 max-w-2xl">
         <h2 id="player-setup-title" class="text-3xl font-bold mb-2">Player Setup</h2>
         <p class="mb-6 text-white/70">Enter names and choose colors.</p>
         
         <div class="player-setup-grid">
             <!-- Player 1 Column -->
             <div class="player-column">
                 <h3 class="text-xl font-bold text-white">Player 1</h3>
                 <div>
                     <label for="p1-name">Name:</label>
                     <input type="text" id="p1-name" value="Player 1" maxlength="15">
                 </div>
                 <div>
                     <label for="p1-color">Color:</label>
                     <select id="p1-color">
                         <option value="#ff4444" selected>Red</option>
                         <option value="#4488ff">Blue</option>
                         <option value="#44ff44">Green</option>
                         <option value="#ffff44">Yellow</option>
                         <option value="#ff8844">Orange</option>
                         <option value="#ff44ff">Pink</option>
                     </select>
                 </div>
                 <div class="text-xs text-left text-white/50 p-2 bg-black/20 rounded">
                    <b>Controls:</b> WASD (Move), E (Reveal), R/F (Flag), Space (Jump)
                 </div>
             </div>
             <!-- Player 2 Column -->
             <div id="p2-column" class="player-column">
                 <h3 class="text-xl font-bold text-white">Player 2</h3>
                 <div>
                     <label for="p2-name">Name:</label>
                     <input type="text" id="p2-name" value="Player 2" maxlength="15">
                 </div>
                 <div>
                     <label for="p2-color">Color:</label>
                     <select id="p2-color">
                         <option value="#ff4444">Red</option>
                         <option value="#4488ff" selected>Blue</option>
                         <option value="#44ff44">Green</option>
                         <option value="#ffff44">Yellow</option>
                         <option value="#ff8844">Orange</option>
                         <option value="#ff44ff">Pink</option>
                     </select>
                 </div>
                 <div class="text-xs text-left text-white/50 p-2 bg-black/20 rounded">
                    <b>Controls:</b> Arrow Keys (Move), ; (Reveal), ' (Flag), Enter (Jump)
                 </div>
             </div>
         </div>

         <button id="start-game-btn" class="modal-btn modal-btn-primary w-full">Start Game</button>
         <button id="player-setup-back-btn" class="modal-btn modal-btn-secondary mt-4 w-full">Back</button>
     </div>
 </div>


 <!-- UI Element for Pointer Lock -->
 <div id="mouse-lock-info">Click to control character</div>

 <!-- Zoom Controls -->
 <div id="zoom-controls">
     <button id="zoom-in-btn" class="zoom-btn">+</button>
     <button id="zoom-out-btn" class="zoom-btn">-</button>
 </div>

 <!-- On-Screen Touch Controls (Initially hidden) -->
 <div id="touch-controls">
     <div id="joystick-area">
         <div id="joystick-thumb"></div>
     </div>
     <div id="action-buttons">
         <div id="reveal-btn" class="action-btn">REVEAL</div>
         <div id="jump-btn" class="action-btn">JUMP</div>
         <div id="flag-btn" class="action-btn">FLAG</div>
         <div id="crouch-btn" class="action-btn">CROUCH</div>
     </div>
 </div>

 <!-- Three.js and GLTFLoader -->
 <script type="importmap">
     {
         "imports": {
             "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.min.js",
             "GLTFLoader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/loaders/GLTFLoader.js"
         }
     }
 </script>

 <!-- Main Application Logic -->
 <script type="module">
     import * as THREE from 'three';
     import { GLTFLoader } from 'GLTFLoader';

     // --- Game Constants ---
     const TILE_SIZE = 1.0;
     const TILE_HEIGHT = 0.1;
     // NEW: Player control mappings
     const PLAYER_CONTROLS = {
         1: {
             up: 'w', down: 's', left: 'a', right: 'd',
             jump: ' ', reveal: 'e', revealAlt: 'c', flag: 'r', flagAlt: 'f',
             crouch: 'z'
         },
         2: {
             up: 'arrowup', down: 'arrowdown', left: 'arrowleft', right: 'arrowright',
             jump: 'enter', reveal: ';', revealAlt: '.', flag: "'", flagAlt: 'l',
             crouch: 'control' // Right control key
         }
     };

     // --- NEW: Player Class ---
     class Player {
         constructor(id, name, color, keybindings, gameController) {
             this.id = id;
             this.name = name;
             this.color = new THREE.Color(color);
             this.keybindings = keybindings;
             this.game = gameController; // Reference to the main class
             this.scene = gameController.scene;

             // 3D Model & Animation
             this.model = null;
             this.mixer = null;
             this.animationsMap = new Map();
             this.activeAction = null;
             this.currentState = 'idle';
             this.oneShotActive = false;
          
             // Physics & Movement
             this.moveDirection = new THREE.Vector3();
             this.rotationSpeed = Math.PI * 0.8;
             this.targetYaw = 0;
             this.currentYaw = 0;
             this.reverseCamera = false;
             this.worldForward = new THREE.Vector3();
             this.finalVelocity = new THREE.Vector3();

             // Input
             this.keysPressed = {};

             // Camera (for split-screen)
             this.camera = new THREE.PerspectiveCamera(45, (window.innerWidth / 2) / window.innerHeight, 0.1, 1000);
             this.followCameraOffset = new THREE.Vector3(0, 2.5, -5);
             this.cameraYaw = 0;
             this.cameraPitch = 0;

             // Highlighter
             this.currentHighlightedTile = { x: -1, y: -1 };
             this.highlighterMesh = null;

             // UI
             this.tagElement = document.getElementById(`p${id}-tag`);
             this.tagElement.textContent = this.name;
             this.tagElement.style.color = color;
             this.tagElement.style.display = 'block';

             this.createHighlighter();
         }

         createHighlighter() {
             const highlighterGeo = new THREE.PlaneGeometry(TILE_SIZE * 0.95, TILE_SIZE * 0.95);
             const highlighterMat = new THREE.MeshBasicMaterial({
                 color: this.color,
                 transparent: true,
                 opacity: 0.5,
                 side: THREE.DoubleSide
             });
             this.highlighterMesh = new THREE.Mesh(highlighterGeo, highlighterMat);
             this.highlighterMesh.rotation.x = -Math.PI / 2;
             this.highlighterMesh.visible = false;
             this.scene.add(this.highlighterMesh);
         }

         loadModel(gltfLoader) {
             return new Promise((resolve, reject) => {
                 gltfLoader.load(
                     'https://threejs.org/examples/models/gltf/RobotExpressive/RobotExpressive.glb',
                     (gltf) => {
                         this.model = gltf.scene;
                         this.model.scale.set(0.4, 0.4, 0.4);
                         this.scene.add(this.model);

                         // Clone materials to apply unique color
                         this.model.traverse(node => {
                             if (node.isMesh) {
                                 node.castShadow = true;
                                 // Check if material is an array (multi-material mesh)
                                 if (Array.isArray(node.material)) {
                                     node.material = node.material.map(mat => {
                                         const newMat = mat.clone();
                                         if (newMat.color) {
                                            newMat.color.lerp(this.color, 0.5); // Blend with base color
                                         }
                                         return newMat;
                                     });
                                 } else if (node.material) {
                                     node.material = node.material.clone();
                                     if (node.material.color) {
                                        node.material.color.lerp(this.color, 0.5); // Blend 50/50
                                     }
                                 }
                             }
                         });

                         this.mixer = new THREE.AnimationMixer(this.model);
                         gltf.animations.forEach(clip => {
                             const action = this.mixer.clipAction(clip);
                             this.animationsMap.set(clip.name, action);
                         });

                         this.mixer.addEventListener('finished', () => {
                             this.oneShotActive = false;
                             this.currentState = 'idle';
                         });

                         this.fadeToAction('Idle', 0);
                         this.currentState = 'idle';
                         resolve();
                     },
                     undefined,
                     (error) => reject(error)
                 );
             });
         }

         handleKeyAction(key, isDown) {
             const bindings = this.keybindings;
             if (isDown && !this.keysPressed[key]) { // First press
                 // Game actions
                 switch (key) {
                     case bindings.jump:
                         this.revealTile();
                         this.currentState = 'jump';
                         break;
                     case bindings.reveal:
                     case bindings.revealAlt:
                         this.revealTile();
                         break;
                     case bindings.flag:
                     case bindings.flagAlt:
                         this.flagTile();
                         break;
                 }
             }
             
             this.keysPressed[key] = isDown; // Update state

             if (this.oneShotActive) return;

             if (isDown) {
                 switch (key) {
                     case bindings.crouch:
                         this.currentState = 'sitting';
                         break;
                     case bindings.down:
                         if (!this.keysPressed[key]) { // First press
                             this.targetYaw += Math.PI;
                         }
                         this.reverseCamera = true;
                         break;
                 }
             } else { // Key up
                 if (key === bindings.crouch) {
                     this.currentState = 'idle';
                 }
                 if (key === bindings.down) {
                     this.reverseCamera = false;
                 }
             }
         }
         
         revealTile() {
            if (this.game.gameOver || this.game.gameWin) return;
            const pos = this.getRobotGridPosition();
            if (!pos) return;

            const tile = this.game.board[pos.x][pos.y];
            if (tile.isRevealed || tile.isFlagged) return;
          
            this.currentState = 'punch'; // Animation feedback
            this.game.recursiveReveal(pos.x, pos.y, this); // Pass this player
         }

         flagTile() {
            if (this.game.gameOver || this.game.gameWin || this.oneShotActive) return;
            const pos = this.getRobotGridPosition();
            if (!pos) return;

            const tile = this.game.board[pos.x][pos.y];
            if (tile.isRevealed) return;
          
            this.currentState = 'sitting';
            setTimeout(() => { if (this.currentState === 'sitting') this.currentState = 'idle'; }, 300);

            tile.isFlagged = !tile.isFlagged;
            this.game.updateTileVisual(pos.x, pos.y); 
            this.game.updateGameUI(); // Global UI
         }
         
         getRobotGridPosition() {
             if (!this.model) return null;
             const { x, z } = this.model.position;
             const gridX = Math.floor(x / TILE_SIZE + this.game.gridSize / 2);
             const gridY = Math.floor(z / TILE_SIZE + this.game.gridSize / 2);

             if (gridX < 0 || gridX >= this.game.gridSize || gridY < 0 || gridY >= this.game.gridSize) {
                 return null;
             }
             return { x: gridX, y: gridY };
         }

         updateMovementState() {
             let moveFwd = 0;
             let rotate = 0;
             let isRunning = false;
             let isMoving = false;
             
             const bindings = this.keybindings;

             if (this.game.inputMode === 'keyboard') {
                 isRunning = this.keysPressed['shift']; // P1 only
              
                 if (this.keysPressed[bindings.up]) {
                     moveFwd = 1; isMoving = true;
                 } else if (this.keysPressed[bindings.down]) {
                     moveFwd = 1; isMoving = true;
                 }
                 if (this.keysPressed[bindings.left]) {
                     rotate = 1;
                 } else if (this.keysPressed[bindings.right]) {
                     rotate = -1;
                 }
             } else { // Touch (only for P1)
                 const joyX = this.game.touchState.joystick.x;
                 const joyY = this.game.touchState.joystick.y;
                 const magnitude = Math.sqrt(joyX * joyX + joyY * joyY);

                 if (magnitude > 0.1) {
                     isMoving = true; moveFwd = 1; rotate = 0;
                     isRunning = magnitude > 0.8;
                     const angle = Math.atan2(joyY, joyX);
                     this.targetYaw = angle + (Math.PI / 2);
                 } else {
                     isMoving = false; moveFwd = 0; rotate = 0; isRunning = false;
                 }
             }
          
             this.moveDirection.z = moveFwd;
             this.moveDirection.x = rotate;

             if (!this.oneShotActive) {
                 const isMovementState = ['idle', 'Walking', 'Running'].includes(this.currentState);
                 if (this.currentState === 'sitting') {
                     // Stay sitting
                 } else if (isMovementState) {
                     if (isMoving || rotate !== 0) {
                         this.currentState = isRunning ? 'Running' : 'Walking';
                     } else {
                         this.currentState = 'idle';
                     }
                 }
             }
         }
      
         update(delta) {
             if (!this.model || !this.mixer) return;
          
             // 1. Determine movement and animation state
             if (!this.game.gameOver) {
                 this.updateMovementState();
             } else {
                 this.moveDirection.z = 0; this.moveDirection.x = 0;
                 if (!this.oneShotActive) this.currentState = 'idle';
             }

             // 2. Play one-shot actions
             if (this.currentState === 'jump') this.playOneShotAction('Jump');
             else if (this.currentState === 'punch') this.playOneShotAction('Punch');
          
             // 3. Play looping animations
             if (!this.oneShotActive) {
                 if (this.currentState === 'sitting') this.fadeToAction('Sitting', 0.2);
                 else if (this.currentState === 'Running') this.fadeToAction('Running', 0.2);
                 else if (this.currentState === 'Walking') this.fadeToAction('Walking', 0.2);
                 else this.fadeToAction('Idle', 0.2);
             }
          
             // 4. Update Model Rotation (Yaw)
             if (this.moveDirection.x !== 0) { // A/D or Left/Right keys
                 this.targetYaw += (this.moveDirection.x * this.rotationSpeed * delta);
             }
             this.currentYaw = THREE.MathUtils.lerp(this.currentYaw, this.targetYaw, 15 * delta);
             this.model.rotation.y = this.currentYaw;

             // 5. Update Model Position
             const moveSpeed = (this.currentState === 'Running' ? 4 : (this.currentState === 'Walking' ? 2 : 0));
             if (moveSpeed > 0 && this.moveDirection.z > 0) {
                 this.model.getWorldDirection(this.worldForward);
                 this.finalVelocity.copy(this.worldForward).multiplyScalar(moveSpeed * delta);
                 this.model.position.add(this.finalVelocity);
             }
          
             // 6. Clamp model position
             const { halfGridSize } = this.game;
             this.model.position.x = THREE.MathUtils.clamp(this.model.position.x, -halfGridSize, halfGridSize);
             this.model.position.z = THREE.MathUtils.clamp(this.model.position.z, -halfGridSize, halfGridSize);
          
             // 7. Update Follow Camera
             const cameraPivot = new THREE.Vector3().copy(this.model.position);
             cameraPivot.y += 1.5;
             let finalCameraOffset = this.followCameraOffset.clone();
             if (this.reverseCamera) finalCameraOffset.z *= -1;
            
             const yawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraYaw);
             const pitchQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.cameraPitch);
             const modelYawQuat = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.currentYaw);
             const finalRotation = new THREE.Quaternion().multiply(modelYawQuat, yawQuat).multiply(pitchQuat);
             finalCameraOffset.applyQuaternion(finalRotation);
             
             this.camera.position.copy(cameraPivot).add(finalCameraOffset);
             this.camera.lookAt(cameraPivot);

             // 8. Update Highlighter
             this.updateHighlighter();

             // 9. Update Name Tag
             this.updateTagPosition();
         }
         
         updateTagPosition() {
             const pos = new THREE.Vector3().copy(this.model.position);
             pos.y += 1.2; // Position above robot's head
             const activeCamera = this.game.getActiveCameraForPlayer(this.id);
             pos.project(activeCamera);

             const width = window.innerWidth;
             const height = window.innerHeight;
             const widthHalf = width / 2;
             const heightHalf = height / 2;

             let screenX = (pos.x * widthHalf) + widthHalf;
             const screenY = - (pos.y * heightHalf) + heightHalf;
             
             // Adjust X position for split screen
             if (this.game.gameMode === 'multi' && this.game.cameraStyle === 'follow') {
                 if (this.id === 1) {
                    screenX = (pos.x * (widthHalf / 2)) + (widthHalf / 2);
                 } else {
                    screenX = (pos.x * (widthHalf / 2)) + widthHalf + (widthHalf / 2);
                 }
             }
             
             // Hide if behind camera or off-screen
             if (pos.z > 1 || screenX < -50 || screenX > width + 50 || screenY < -50 || screenY > height + 50) {
                 this.tagElement.style.display = 'none';
             } else {
                 this.tagElement.style.display = 'block';
                 this.tagElement.style.left = `${screenX}px`;
                 this.tagElement.style.top = `${screenY}px`;
             }
         }

         updateHighlighter() {
             if (this.game.gameOver || !this.model || this.game.gameWin) {
                 if (this.highlighterMesh) this.highlighterMesh.visible = false;
                 return;
             }
             const pos = this.getRobotGridPosition();
             if (pos) {
                 const tile = this.game.board[pos.x][pos.y];
                 if (tile && tile.mesh) {
                     if (pos.x !== this.currentHighlightedTile.x || pos.y !== this.currentHighlightedTile.y) {
                         this.currentHighlightedTile = pos;
                         this.highlighterMesh.position.copy(tile.mesh.position);
                         this.highlighterMesh.position.y = (TILE_HEIGHT / 2) + 0.01;
                     }
                     this.highlighterMesh.visible = true;
                 } else {
                     this.highlighterMesh.visible = false;
                 }
             } else {
                 this.highlighterMesh.visible = false;
             }
         }

         fadeToAction(name, duration) {
             const nextAction = this.animationsMap.get(name);
             if (!nextAction) return;
             if (this.activeAction === nextAction) return;
             if (this.activeAction) this.activeAction.fadeOut(duration);
             nextAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).play();
             this.activeAction = nextAction;
         }
      
         playOneShotAction(name) {
             if (this.oneShotActive) return;
             const action = this.animationsMap.get(name);
             if (!action) return;
             this.oneShotActive = true;
             action.setLoop(THREE.LoopOnce, 1);
             this.fadeToAction(name, 0.2);
         }
     }
     // --- END Player Class ---


     // --- Main Controller Class ---
     class CharacterController {
         constructor() {
             // DOM Elements
             this.container = document.getElementById('container');
             this.loaderEl = document.getElementById('loader');
             this.loaderSubtextEl = document.getElementById('loader-subtext');
             this.modalEl = document.getElementById('input-modal');
             this.gameModeModalEl = document.getElementById('game-mode-modal');
             this.playerSetupModalEl = document.getElementById('player-setup-modal');
             this.touchControlsEl = document.getElementById('touch-controls');
             this.mouseLockInfoEl = document.getElementById('mouse-lock-info');
          
             // UI Elements
             this.levelText = document.getElementById('level-text');
             this.minesText = document.getElementById('mines-text');
             this.gameStatusText = document.getElementById('game-status');
             this.cameraBtn = document.getElementById('camera-btn');
             this.newGameBtn = document.getElementById('new-game-btn');
             this.levelInput = document.getElementById('level-input');
             this.levelGoBtn = document.getElementById('level-go-btn');
             
             // 3D Scene
             this.scene = new THREE.Scene();
             this.topDownCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
             this.cameraStyle = 'topDown';
             this.renderer = new THREE.WebGLRenderer({ antialias: true });
             this.clock = new THREE.Clock();
             this.gltfLoader = new GLTFLoader();
          
             // Players
             this.player1 = null;
             this.player2 = null;
          
             // Input
             this.inputMode = 'keyboard'; // 'keyboard' or 'touch'
             this.gameMode = 'single'; // 'single' or 'multi'
          
             // Touch State (Only for P1)
             this.touchState = {
                 joystick: { x: 0, y: 0, active: false },
                 camera: { active: false, touchId: null, lastX: 0, lastY: 0 }
             };
          
             // Minesweeper Game State
             this.level = 1;
             this.gridSize = 0;
             this.mineCount = 0;
             this.board = [];
             this.boardGroup = new THREE.Group();
             this.revealedCells = 0;
             this.totalNonMineCells = 0;
             this.minesFlagged = 0;
             this.gameOver = false;
             this.gameWin = false;
             this.halfGridSize = 0;

             // Level Theming
             this.levelColor = '#333333';
             this.levelBackgroundColor = '#111111';
             this.sceneryGroup = new THREE.Group();

             // Tile Textures
             this.tileTextures = {};

             // 3D Flag reusable assets
             this.flagPoleGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8);
             this.flagPoleMat = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
             this.flagClothGeo = new THREE.PlaneGeometry(0.3, 0.2);
             this.flagClothMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
             this.flagBaseGeo = new THREE.CircleGeometry(0.2, 16);
             this.flagBaseMat = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
             
             // Zoom
             this.defaultTopDownHeight = 20;

             // Pre-bind methods
             this.animate = this.animate.bind(this);
             this.onWindowResize = this.onWindowResize.bind(this);
             this.boundOnMouseMove = this.onMouseMove.bind(this);
             this.boundOnPointerLockChange = this.onPointerLockChange.bind(this);
             this.boundOnKeyDown = this.onKeyDown.bind(this);
             this.boundOnKeyUp = this.onKeyUp.bind(this);
             this.boundOnContainerClick = this.onContainerClick.bind(this);
             this.boundOnTouchStart = this.onTouchStart.bind(this);
             this.boundOnTouchMove = this.onTouchMove.bind(this);
             this.boundOnTouchEnd = this.onTouchEnd.bind(this);
             this.boundOnJoystickMove = this.onJoystickMove.bind(this);
             this.boundOnJoystickEnd = this.onJoystickEnd.bind(this);
             this.boundOnCrouchStart = this.onCrouchStart.bind(this);
             this.boundOnCrouchEnd = this.onCrouchEnd.bind(this);
             this.boundOnJumpStart = this.onJumpStart.bind(this);
             this.boundOnRevealStart = this.onRevealStart.bind(this);
             this.boundOnFlagStart = this.onFlagStart.bind(this);
             this.boundCycleCameraView = this.cycleCameraView.bind(this);
             this.boundStartNewGame = this.startNewGame.bind(this, 1);
             this.boundGoToLevel = this.goToLevel.bind(this);
             this.boundZoomCamera = this.zoomCamera.bind(this);

             this.init();
         }
      
         mulberry32(a) {
             return function() {
                 a |= 0; a = a + 0x6D2B79F5 | 0;
                 var t = Math.imul(a ^ a >>> 15, 1 | a);
                 t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
                 return ((t ^ t >>> 14) >>> 0) / 4294967296;
             }
         }
         
         generateLevelColor(level) {
             const rand = this.mulberry32(level * 12345);
             const hue = Math.floor(rand() * 360);
             const saturation = Math.floor(rand() * 30) + 70;
             const lightness = Math.floor(rand() * 20) + 20;
             return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
         }

         init() {
             this.scene.background = new THREE.Color(this.levelBackgroundColor);
             this.scene.fog = new THREE.Fog(this.levelBackgroundColor, 20, 100); 

             this.topDownCamera.position.set(0, 20, 0);
             this.topDownCamera.lookAt(0, 0, 0);
             this.scene.add(this.topDownCamera);

             this.renderer.setSize(window.innerWidth, window.innerHeight);
             this.renderer.shadowMap.enabled = true;
             this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
             this.renderer.toneMappingExposure = 1;
             this.renderer.setScissorTest(true); // Enable for split-screen
             this.container.appendChild(this.renderer.domElement);

             const hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1.5);
             hemiLight.position.set(0, 50, 0);
             this.scene.add(hemiLight);

             const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
             dirLight.position.set(20, 30, 10);
             dirLight.castShadow = true;
             dirLight.shadow.camera.top = 20;
             dirLight.shadow.camera.bottom = -20;
             dirLight.shadow.camera.left = -20;
             dirLight.shadow.camera.right = 20;
             dirLight.shadow.mapSize.width = 2048;
             dirLight.shadow.mapSize.height = 2048;
             this.scene.add(dirLight);
          
             this.scene.add(this.boardGroup);
             this.scene.add(this.sceneryGroup);

             // Bind UI
             window.addEventListener('resize', this.onWindowResize);
             // Modal 1: Input
             document.getElementById('touch-btn').onclick = () => this.setupInputMode('touch');
             document.getElementById('keyboard-btn').onclick = () => this.setupInputMode('keyboard');
             
             // Modal 2: Game Mode
             document.getElementById('game-mode-back-btn').onclick = () => {
                 this.gameModeModalEl.style.display = 'none';
                 this.modalEl.style.display = 'flex';
             };
             document.getElementById('single-player-btn').onclick = () => this.setupGameMode('single');
             document.getElementById('multi-player-btn').onclick = () => this.setupGameMode('multi');

             // Modal 3: Player Setup
             document.getElementById('player-setup-back-btn').onclick = () => {
                 this.playerSetupModalEl.style.display = 'none';
                 this.gameModeModalEl.style.display = 'flex';
             };
             document.getElementById('start-game-btn').onclick = () => this.initGame();


             this.cameraBtn.addEventListener('click', this.boundCycleCameraView);
             this.newGameBtn.addEventListener('click', this.boundStartNewGame);
             this.levelGoBtn.addEventListener('click', this.boundGoToLevel);
             this.levelInput.addEventListener('keydown', (e) => {
                 if (e.key === 'Enter') { e.preventDefault(); this.boundGoToLevel(); }
             });
             
             document.getElementById('zoom-in-btn').onclick = () => this.zoomCamera(0.8);
             document.getElementById('zoom-out-btn').onclick = () => this.zoomCamera(1.25);
          
             // Start Game (logic only, models loaded in initGame)
             this.startNewGame(1, false); // Don't init players yet
             this.loaderEl.style.display = 'none';
             this.modalEl.style.display = 'flex';
         }
      
         setupInputMode(mode) {
             this.inputMode = mode;
             this.modalEl.style.display = 'none';

             if (mode === 'keyboard') {
                 // Show game mode select
                 this.gameModeModalEl.style.display = 'flex';
             } else {
                 // Touch is single player only
                 this.setupGameMode('single');
             }
         }

         setupGameMode(mode) {
             this.gameMode = mode;
             this.gameModeModalEl.style.display = 'none';
             this.playerSetupModalEl.style.display = 'flex';

             if (mode === 'single') {
                 document.getElementById('player-setup-title').textContent = 'Player Setup';
                 document.getElementById('p2-column').style.display = 'none';
                 document.getElementById('player-setup-back-btn').style.display = 'block';
                 if (this.inputMode === 'touch') {
                    // Back button goes to input select
                    document.getElementById('player-setup-back-btn').onclick = () => {
                        this.playerSetupModalEl.style.display = 'none';
                        this.modalEl.style.display = 'flex';
                    };
                 }
             } else {
                 document.getElementById('player-setup-title').textContent = '2-Player Setup';
                 document.getElementById('p2-column').style.display = 'flex';
                 // Back button goes to game mode select
                 document.getElementById('player-setup-back-btn').onclick = () => {
                     this.playerSetupModalEl.style.display = 'none';
                     this.gameModeModalEl.style.display = 'flex';
                 };
             }
         }

         async initGame() {
            this.playerSetupModalEl.style.display = 'none';
            this.loaderEl.style.display = 'flex';
            this.loaderSubtextEl.textContent = 'Loading 3D Models...';
            
            // Get Player 1 Config
            const p1Name = document.getElementById('p1-name').value || 'Player 1';
            const p1Color = document.getElementById('p1-color').value;
            this.player1 = new Player(1, p1Name, p1Color, PLAYER_CONTROLS[1], this);
            
            const loadPromises = [this.player1.loadModel(this.gltfLoader)];

            if (this.gameMode === 'multi') {
                const p2Name = document.getElementById('p2-name').value || 'Player 2';
                const p2Color = document.getElementById('p2-color').value;
                this.player2 = new Player(2, p2Name, p2Color, PLAYER_CONTROLS[2], this);
                loadPromises.push(this.player2.loadModel(this.gltfLoader));
                
                // --- FIX: MOVED POSITIONING CODE ---
                // this.player1.model.position.x = -1; // ERROR: model is null
                // this.player1.targetYaw = Math.PI / 2; // Face right
                // this.player2.model.position.x = 1;
                // this.player2.targetYaw = -Math.PI / 2; // Face left
            }
            
            try {
                await Promise.all(loadPromises);
            } catch (error) {
                console.error("Failed to load models:", error);
                this.loaderSubtextEl.textContent = 'Error loading models. Please refresh.';
                return;
            }

            // --- FIX: MOVED POSITIONING CODE HERE ---
            // Position players apart *after* models are loaded
            if (this.gameMode === 'multi') {
                this.player1.model.position.x = -1;
                this.player1.targetYaw = Math.PI / 2; // Face right
                this.player1.currentYaw = this.player1.targetYaw; // Snap to new yaw
                this.player2.model.position.x = 1;
                this.player2.targetYaw = -Math.PI / 2; // Face left
                this.player2.currentYaw = this.player2.targetYaw; // Snap to new yaw
            }

            // Setup controls
             if (this.inputMode === 'keyboard') {
                 this.initKeyboardControls();
                 if (this.cameraStyle !== 'topDown') {
                     this.mouseLockInfoEl.style.display = 'block';
                 }
             } else {
                 this.initTouchControls();
             }
             
             if (this.cameraStyle === 'topDown' || this.cameraStyle === 'follow') {
                 document.getElementById('zoom-controls').style.display = 'flex';
             }
          
            this.loaderEl.style.display = 'none';
            this.startNewGame(this.level, true); // Re-run to position players
            this.animate(); // Start the loop
         }


         // --- Game Logic ---
      
         startNewGame(level, positionPlayers = true) {
             if (this.levelInput) this.levelInput.value = level;
             
             this.gameOver = false;
             this.gameWin = false;
             this.level = level;
             if (level > 100) this.level = 100;
          
             this.levelColor = this.generateLevelColor(this.level);
             this.levelBackgroundColor = this.generateLevelColor(this.level + 1000); 
             this.scene.background = new THREE.Color(this.levelBackgroundColor);
             this.scene.fog.color.set(this.levelBackgroundColor);
             this.tileTextures = this.createTileTextures(this.levelColor);
             this.createScenery();

             this.gridSize = Math.min(10 + Math.floor(this.level / 2), 40);
             this.mineCount = Math.min(5 + Math.floor(this.level * 1.5), Math.floor(this.gridSize * this.gridSize * 0.25));
             this.halfGridSize = (this.gridSize * TILE_SIZE) / 2.0;
             this.revealedCells = 0;
             this.totalNonMineCells = (this.gridSize * this.gridSize) - this.mineCount;
             this.minesFlagged = 0;
          
             this.board = this.createMinefield(this.gridSize, this.mineCount);
             this.createVisualBoard();

             // Reset players
             if (positionPlayers) {
                if (this.player1 && this.player1.model) {
                    this.player1.model.position.set(this.gameMode === 'multi' ? -1 : 0, 0, 0);
                    this.player1.targetYaw = this.gameMode === 'multi' ? Math.PI / 2 : 0;
                    this.player1.currentYaw = this.player1.targetYaw;
                    if (this.player1.highlighterMesh) this.player1.highlighterMesh.visible = false;
                }
                if (this.player2 && this.player2.model) {
                    this.player2.model.position.set(1, 0, 0);
                    this.player2.targetYaw = -Math.PI / 2;
                    this.player2.currentYaw = this.player2.targetYaw;
                    if (this.player2.highlighterMesh) this.player2.highlighterMesh.visible = false;
                }
             }
          
             this.updateGameUI();
             this.gameStatusText.textContent = '';
             this.updateTopDownCamera();
         }
         
         goToLevel() {
             let level = parseInt(this.levelInput.value, 10);
             if (isNaN(level) || level < 1) level = 1;
             if (level > 100) level = 100;
             this.levelInput.value = level;
             this.startNewGame(level, true);
         }

         createScenery() {
             while (this.sceneryGroup.children.length) {
                 this.sceneryGroup.remove(this.sceneryGroup.children[0]);
             }
             const groundGeo = new THREE.PlaneGeometry(200, 200);
             const groundColor = new THREE.Color(this.levelColor).multiplyScalar(0.2);
             const groundMat = new THREE.MeshPhongMaterial({ color: groundColor, shininess: 10 });
             const groundMesh = new THREE.Mesh(groundGeo, groundMat);
             groundMesh.rotation.x = -Math.PI / 2;
             groundMesh.position.y = -TILE_HEIGHT - 0.05;
             groundMesh.receiveShadow = true;
             this.sceneryGroup.add(groundMesh);
         }

         createMinefield(size, mines) {
             let board = Array(size).fill(null).map(() => Array(size).fill(null).map(() => ({
                 isMine: false, number: 0, isRevealed: false, isFlagged: false,
                 mesh: null, materials: [], flagMesh: null
             })));
             let minesPlaced = 0;
             while (minesPlaced < mines) {
                 const x = Math.floor(Math.random() * size);
                 const y = Math.floor(Math.random() * size);
                 // Don't place mines in the center starting area
                 const center = size / 2;
                 if (Math.abs(x - center) < 2 && Math.abs(y - center) < 2) continue;
                 
                 if (!board[x][y].isMine) {
                     board[x][y].isMine = true;
                     minesPlaced++;
                 }
             }
             for (let x = 0; x < size; x++) {
                 for (let y = 0; y < size; y++) {
                     if (board[x][y].isMine) continue;
                     let count = 0;
                     for (let dx = -1; dx <= 1; dx++) {
                         for (let dy = -1; dy <= 1; dy++) {
                             if (dx === 0 && dy === 0) continue;
                             const nx = x + dx, ny = y + dy;
                             if (nx >= 0 && nx < size && ny >= 0 && ny < size && board[nx][ny].isMine) {
                                 count++;
                             }
                         }
                     }
                     board[x][y].number = count;
                 }
             }
             return board;
         }

         createVisualBoard() {
             while (this.boardGroup.children.length) {
                 this.boardGroup.children[0].traverse(child => {
                     if (child.isMesh) {
                         child.geometry.dispose();
                         if (Array.isArray(child.material)) child.material.forEach(mat => mat.dispose());
                         else child.material.dispose();
                     }
                 });
                 this.boardGroup.remove(this.boardGroup.children[0]);
             }
             const tileGeo = new THREE.BoxGeometry(TILE_SIZE * 0.95, TILE_HEIGHT, TILE_SIZE * 0.95);
             const matHidden = new THREE.MeshPhongMaterial({ map: this.tileTextures.hidden });
             const matMine = new THREE.MeshPhongMaterial({ map: this.tileTextures.mine });
             const matMineRed = new THREE.MeshPhongMaterial({ map: this.tileTextures.mineRed });
             const matRevealedBase = new THREE.MeshPhongMaterial({ map: this.tileTextures[0] }); 
             const numberMaterials = [
                 matRevealedBase,
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[1] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[2] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[3] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[4] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[5] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[6] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[7] }),
                 new THREE.MeshPhongMaterial({ map: this.tileTextures[8] }),
             ];
             for (let x = 0; x < this.gridSize; x++) {
                 for (let y = 0; y < this.gridSize; y++) {
                     const materials = [matHidden, matHidden, matHidden, matHidden, matHidden, matHidden];
                     const tileMesh = new THREE.Mesh(tileGeo, materials);
                     tileMesh.position.set(
                         (x - this.gridSize / 2 + 0.5) * TILE_SIZE,
                         -TILE_HEIGHT / 2,
                         (y - this.gridSize / 2 + 0.5) * TILE_SIZE
                     );
                     tileMesh.receiveShadow = true;
                     this.boardGroup.add(tileMesh);
                     this.board[x][y].mesh = tileMesh;
                     this.board[x][y].materials = {
                         hidden: matHidden, mine: matMine, mineRed: matMineRed,
                         number: numberMaterials[this.board[x][y].number],
                         revealedBase: matRevealedBase 
                     };
                 }
             }
         }
      
         updateTopDownCamera() {
             const boardWorldSize = this.gridSize * TILE_SIZE;
             this.defaultTopDownHeight = Math.max(15, boardWorldSize * 1.2);
             this.topDownCamera.position.y = this.defaultTopDownHeight;
             this.topDownCamera.position.x = 0;
             this.topDownCamera.position.z = 0;
             this.topDownCamera.lookAt(0, 0, 0);
             this.topDownCamera.updateProjectionMatrix();
         }
      
         // player = player who triggered the reveal
         recursiveReveal(x, y, player) {
             if (x < 0 || x >= this.gridSize || y < 0 || y >= this.gridSize) return;
             const tile = this.board[x][y];
             if (tile.isRevealed || tile.isFlagged) return;

             if (tile.isMine) {
                 this.gameOver = true;
                 this.revealAllMines(x, y);
                 this.gameStatusText.textContent = `${player.name} HIT A MINE! GAME OVER!`;
                 this.gameStatusText.style.color = '#ff4444';
                 this.newGameBtn.textContent = 'Play Again?';
             } else {
                 tile.isRevealed = true;
                 this.revealedCells++;
                 this.updateTileVisual(x, y);

                 if (tile.number === 0) {
                     for (let dx = -1; dx <= 1; dx++) {
                         for (let dy = -1; dy <= 1; dy++) {
                             if (dx === 0 && dy === 0) continue;
                             this.recursiveReveal(x + dx, y + dy, player); // Recurse
                         }
                     }
                 }
                 this.checkWinCondition();
             }
             this.updateGameUI();
         }
      
         checkWinCondition() {
             if (this.revealedCells === this.totalNonMineCells) {
                 this.gameWin = true;
                 this.gameOver = true;
                 this.gameStatusText.textContent = `LEVEL ${this.level} CLEARED!`;
                 this.gameStatusText.style.color = '#44ff44';
                 this.revealAllMines(null, null, true);
                 this.newGameBtn.textContent = `Next Level (${this.level + 1})`;
                 setTimeout(() => {
                     if (this.level < 100) {
                         this.startNewGame(this.level + 1, true);
                     } else {
                         this.gameStatusText.textContent = 'ALL LEVELS CLEARED!';
                         this.newGameBtn.textContent = 'Play Again?';
                         this.level = 0;
                     }
                 }, 2000);
             }
         }

         revealAllMines(hitX, hitY, isWin = false) {
             for (let x = 0; x < this.gridSize; x++) {
                 for (let y = 0; y < this.gridSize; y++) {
                     const tile = this.board[x][y];
                     if (tile.isMine) {
                         tile.isRevealed = true;
                         if (isWin) tile.isFlagged = true;
                         else if (x === hitX && y === hitY) tile.hit = true;
                         this.updateTileVisual(x, y);
                     }
                 }
             }
         }
      
         updateTileVisual(x, y) {
             const tile = this.board[x][y];
             if (!tile || !tile.mesh) return;
             let topMaterial, sideMaterial;
          
             if (tile.isRevealed) {
                 topMaterial = tile.isMine ? (tile.hit ? tile.materials.mineRed : tile.materials.mine) : tile.materials.number;
                 sideMaterial = tile.materials.revealedBase;
                 if (tile.flagMesh) {
                     this.boardGroup.remove(tile.flagMesh);
                     this.disposeMesh(tile.flagMesh);
                     tile.flagMesh = null;
                 }
             } else if (tile.isFlagged) {
                 topMaterial = tile.materials.revealedBase; 
                 sideMaterial = tile.materials.revealedBase;
                 if (!tile.flagMesh) {
                     tile.flagMesh = this.createFlagObject();
                     tile.flagMesh.position.copy(tile.mesh.position);
                     tile.flagMesh.position.y += (TILE_HEIGHT / 2) + 0.01;
                     this.boardGroup.add(tile.flagMesh);
                 }
             } else {
                 topMaterial = tile.materials.hidden;
                 sideMaterial = tile.materials.hidden;
                 if (tile.flagMesh) {
                     this.boardGroup.remove(tile.flagMesh);
                     this.disposeMesh(tile.flagMesh);
                     tile.flagMesh = null;
                 }
             }
             const materials = tile.mesh.material;
             materials[0] = sideMaterial; materials[1] = sideMaterial;
             materials[2] = topMaterial;  materials[3] = sideMaterial;
             materials[4] = sideMaterial; materials[5] = sideMaterial;
             tile.mesh.material.needsUpdate = true;
         }

         updateGameUI() {
             this.levelText.textContent = this.level;
             const flagsPlaced = this.board.flat().filter(t => t.isFlagged).length;
             this.minesText.textContent = this.mineCount - flagsPlaced;
         }
      
         cycleCameraView() {
             const modes = ['topDown', 'follow'];
             let currentIndex = modes.indexOf(this.cameraStyle);
             currentIndex = (currentIndex + 1) % modes.length;
             this.cameraStyle = modes[currentIndex];
             
             const zoomControls = document.getElementById('zoom-controls');
             if (this.cameraStyle === 'topDown' || this.cameraStyle === 'follow') {
                 zoomControls.style.display = 'flex';
                 if (this.cameraStyle === 'follow' && this.inputMode === 'keyboard') {
                     this.mouseLockInfoEl.style.display = 'block';
                 } else {
                     this.mouseLockInfoEl.style.display = 'none';
                 }
                 if (this.cameraStyle === 'topDown' && document.pointerLockElement === this.container) {
                     document.exitPointerLock();
                 }
             }
             this.onWindowResize(); // Update camera aspect ratios
         }
         
         zoomCamera(factor) {
             if (this.cameraStyle === 'topDown') {
                 this.topDownCamera.position.y *= factor;
                 this.topDownCamera.position.y = THREE.MathUtils.clamp(
                     this.topDownCamera.position.y, 5, this.defaultTopDownHeight * 2
                 );
             } else if (this.cameraStyle === 'follow') {
                if (this.player1) this.player1.followCameraOffset.multiplyScalar(factor);
                if (this.player2) this.player2.followCameraOffset.multiplyScalar(factor);
                // Clamping is handled inside Player class if needed, but this is simpler
             }
         }
         
         createFlagObject() {
             const flagGroup = new THREE.Group();
             const pole = new THREE.Mesh(this.flagPoleGeo, this.flagPoleMat);
             pole.position.y = 0.3;
             flagGroup.add(pole);
             const cloth = new THREE.Mesh(this.flagClothGeo, this.flagClothMat);
             cloth.position.set(0.15, 0.5, 0);
             flagGroup.add(cloth);
             const base = new THREE.Mesh(this.flagBaseGeo, this.flagBaseMat);
             base.rotation.x = -Math.PI / 2;
             base.position.y = 0.01;
             flagGroup.add(base);
             flagGroup.rotation.y = Math.PI / 4;
             return flagGroup;
         }
         
         disposeMesh(mesh) {
             mesh.traverse(child => {
                 if (child.isMesh) child.geometry.dispose();
             });
         }
      
         createTileTextures(levelColor) {
             const textures = {};
             const size = 128;
             const colors = ['#0000ff', '#008200', '#ff0000', '#000084', '#840000', '#008284', '#840084', '#FFFFFF'];
             const createTexture = (baseColor, drawFn) => {
                 const canvas = document.createElement('canvas');
                 const ctx = canvas.getContext('2d');
                 canvas.width = size; canvas.height = size;
                 ctx.fillStyle = baseColor;
                 ctx.fillRect(0, 0, size, size);
                 drawFn(ctx, size);
                 const texture = new THREE.CanvasTexture(canvas);
                 texture.colorSpace = THREE.SRGBColorSpace;
                 return texture;
             };
             textures[0] = createTexture(levelColor, () => {});
             for(let i = 1; i <= 8; i++) {
                 textures[i] = createTexture(levelColor, (ctx, size) => {
                     ctx.fillStyle = colors[i - 1];
                     ctx.font = 'bold 80px sans-serif';
                     ctx.textAlign = 'center';
                     ctx.textBaseline = 'middle';
                     ctx.fillText(i.toString(), size / 2, size / 2 + 5);
                 });
             }
             textures.hidden = createTexture('#888888', (ctx, size) => {
                 ctx.strokeStyle = '#999999'; ctx.lineWidth = 10;
                 ctx.strokeRect(0, 0, size, size);
             });
             textures.mine = createTexture('#DDDDDD', (ctx, size) => {
                 ctx.fillStyle = 'black'; ctx.font = 'bold 80px sans-serif';
                 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                 ctx.fillText('', size / 2, size / 2 + 5);
             });
             textures.mineRed = createTexture('red', (ctx, size) => {
                 ctx.fillStyle = 'black'; ctx.font = 'bold 80px sans-serif';
                 ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                 ctx.fillText('', size / 2, size / 2 + 5);
             });
             return textures;
         }

         // --- Input Handlers (Keyboard & Mouse) ---
         initKeyboardControls() {
             document.addEventListener('keydown', this.boundOnKeyDown);
             document.addEventListener('keyup', this.boundOnKeyUp);
             this.container.addEventListener('click', this.boundOnContainerClick);
             document.addEventListener('pointerlockchange', this.boundOnPointerLockChange);
         }
      
         onKeyDown(e) {
             if (e.key === ' ') e.preventDefault();
             const key = e.key.toLowerCase();
             if (this.player1) this.player1.handleKeyAction(key, true);
             if (this.player2) this.player2.handleKeyAction(key, true);
             // Global keys
             if (!e.repeat) {
                 if (key === 'v') this.cycleCameraView();
             }
         }
      
         onKeyUp(e) {
             const key = e.key.toLowerCase();
             if (this.player1) this.player1.handleKeyAction(key, false);
             if (this.player2) this.player2.handleKeyAction(key, false);
         }

         onContainerClick() {
             if (this.cameraStyle === 'follow') this.container.requestPointerLock();
         }
      
         onPointerLockChange() {
             if (document.pointerLockElement === this.container) {
                 document.addEventListener('mousemove', this.boundOnMouseMove, false);
                 this.mouseLockInfoEl.style.display = 'none';
             } else {
                 document.removeEventListener('mousemove', this.boundOnMouseMove, false);
                 if (this.inputMode === 'keyboard' && this.cameraStyle !== 'topDown') {
                     this.mouseLockInfoEl.style.display = 'block';
                 }
             }
         }
      
         onMouseMove(e) {
             if (!e.movementX && !e.movementY) return;
             if (this.cameraStyle === 'topDown') return;
          
             const deltaX = e.movementX * 0.003;
             const deltaY = e.movementY * 0.003;
             
             if (this.gameMode === 'single' || (e.clientX < window.innerWidth / 2)) {
                 // Mouse affects P1 (or P1 in single player)
                 if (this.player1) {
                    this.player1.cameraYaw -= deltaX;
                    this.player1.cameraPitch -= deltaY;
                    this.player1.cameraPitch = THREE.MathUtils.clamp(this.player1.cameraPitch, -Math.PI / 3, Math.PI / 2.5);
                 }
             } else {
                 // Mouse affects P2
                 if (this.player2) {
                    this.player2.cameraYaw -= deltaX;
                    this.player2.cameraPitch -= deltaY;
                    this.player2.cameraPitch = THREE.MathUtils.clamp(this.player2.cameraPitch, -Math.PI / 3, Math.PI / 2.5);
                 }
             }
         }

         // --- Input Handlers (Touch - P1 Only) ---
         initTouchControls() {
             this.touchControlsEl.style.display = 'block';
             const joystickArea = document.getElementById('joystick-area');
             this.joystick = {
                 area: joystickArea,
                 thumb: document.getElementById('joystick-thumb'),
                 rect: joystickArea.getBoundingClientRect(),
                 radius: joystickArea.getBoundingClientRect().width / 2,
             };
             this.joystick.center = {
                 x: this.joystick.rect.left + this.joystick.radius,
                 y: this.joystick.rect.top + this.joystick.radius
             };
             joystickArea.addEventListener('touchstart', this.boundOnJoystickMove, { passive: false });
             joystickArea.addEventListener('touchmove', this.boundOnJoystickMove, { passive: false });
             joystickArea.addEventListener('touchend', this.boundOnJoystickEnd, false);
             joystickArea.addEventListener('touchcancel', this.boundOnJoystickEnd, false);
             document.getElementById('jump-btn').addEventListener('touchstart', this.boundOnJumpStart, { passive: false });
             document.getElementById('reveal-btn').addEventListener('touchstart', this.boundOnRevealStart, { passive: false });
             document.getElementById('flag-btn').addEventListener('touchstart', this.boundOnFlagStart, { passive: false });
             const crouchBtn = document.getElementById('crouch-btn');
             crouchBtn.addEventListener('touchstart', this.boundOnCrouchStart, { passive: false });
             crouchBtn.addEventListener('touchend', this.boundOnCrouchEnd, false);
             crouchBtn.addEventListener('touchcancel', this.boundOnCrouchEnd, false);
             this.renderer.domElement.addEventListener('touchstart', this.boundOnTouchStart, { passive: false });
             this.renderer.domElement.addEventListener('touchmove', this.boundOnTouchMove, { passive: false });
             this.renderer.domElement.addEventListener('touchend', this.boundOnTouchEnd, false);
             this.renderer.domElement.addEventListener('touchcancel', this.boundOnTouchEnd, false);
         }
         onCrouchStart(e) { e.preventDefault(); if (this.player1) this.player1.currentState = 'sitting'; }
         onCrouchEnd(e) { e.preventDefault(); if (this.player1) this.player1.currentState = 'idle'; }
         onJumpStart(e) { e.preventDefault(); if (this.player1) { this.player1.revealTile(); this.player1.currentState = 'jump'; } }
         onRevealStart(e) { e.preventDefault(); if (this.player1) this.player1.revealTile(); }
         onFlagStart(e) { e.preventDefault(); if (this.player1) this.player1.flagTile(); }
         onJoystickMove(e) {
             e.preventDefault();
             this.touchState.joystick.active = true;
             const touch = e.touches[0];
             let x = touch.clientX - this.joystick.center.x;
             let y = touch.clientY - this.joystick.center.y;
             const distance = Math.sqrt(x*x + y*y);
             const angle = Math.atan2(y, x);
             if (distance > this.joystick.radius) {
                 x = Math.cos(angle) * this.joystick.radius;
                 y = Math.sin(angle) * this.joystick.radius;
             }
             this.joystick.thumb.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
             this.touchState.joystick.x = x / this.joystick.radius;
             this.touchState.joystick.y = y / this.joystick.radius;
         }
         onJoystickEnd(e) {
             e.preventDefault();
             this.touchState.joystick.active = false;
             this.touchState.joystick.x = 0; this.touchState.joystick.y = 0;
             this.joystick.thumb.style.transform = 'translate(-50%, -50%)';
         }
         onTouchStart(e) {
             if (e.target.closest('#touch-controls') || e.target.closest('#game-ui') || e.target.closest('#left-ui-container') || e.target.closest('#zoom-controls')) return;
             e.preventDefault();
             if (this.cameraStyle === 'topDown' || !this.player1) return;
             if (!this.touchState.camera.active) {
                 const touch = e.changedTouches[0];
                 this.touchState.camera.active = true;
                 this.touchState.camera.touchId = touch.identifier;
                 this.touchState.camera.lastX = touch.clientX;
                 this.touchState.camera.lastY = touch.clientY;
             }
         }
         onTouchMove(e) {
             if (!this.touchState.camera.active || this.cameraStyle === 'topDown' || !this.player1) return;
             e.preventDefault();
             let cameraTouch = null;
             for (let touch of e.changedTouches) {
                 if (touch.identifier === this.touchState.camera.touchId) { cameraTouch = touch; break; }
             }
             if (!cameraTouch) return;
             const deltaX = cameraTouch.clientX - this.touchState.camera.lastX;
             const deltaY = cameraTouch.clientY - this.touchState.camera.lastY;
             this.touchState.camera.lastX = cameraTouch.clientX;
             this.touchState.camera.lastY = cameraTouch.clientY;
             this.player1.cameraYaw -= deltaX * 0.01;
             this.player1.cameraPitch -= deltaY * 0.01;
             this.player1.cameraPitch = THREE.MathUtils.clamp(this.player1.cameraPitch, -Math.PI / 3, Math.PI / 2.5);
         }
         onTouchEnd(e) {
             for (let touch of e.changedTouches) {
                 if (touch.identifier === this.touchState.camera.touchId) {
                     this.touchState.camera.active = false;
                     this.touchState.camera.touchId = null;
                     break;
                 }
             }
         }
      
         // --- Update & Render Loop ---
         
         getActiveCameraForPlayer(playerId) {
            if (this.cameraStyle === 'topDown') {
                return this.topDownCamera;
            }
            if (playerId === 1) {
                return this.player1.camera;
            }
            if (playerId === 2 && this.player2) {
                return this.player2.camera;
            }
            return this.player1.camera; // Fallback
         }

         animate() {
             requestAnimationFrame(this.animate);
             const delta = this.clock.getDelta();
             const width = window.innerWidth;
             const height = window.innerHeight;

             // Update players
             if (this.player1) this.player1.update(delta);
             if (this.player2) this.player2.update(delta);
             
             // Update Mixers
             if (this.player1 && this.player1.mixer) this.player1.mixer.update(delta);
             if (this.player2 && this.player2.mixer) this.player2.mixer.update(delta);

             // --- Render Logic ---
             if (this.cameraStyle === 'topDown') {
                 // Single, shared top-down view
                 this.renderer.setViewport(0, 0, width, height);
                 this.renderer.setScissor(0, 0, width, height);
                 this.renderer.render(this.scene, this.topDownCamera);
             
             } else { // 'follow' mode
                 if (this.gameMode === 'single') {
                     // Single-player follow view
                     if (this.player1) {
                        this.renderer.setViewport(0, 0, width, height);
                        this.renderer.setScissor(0, 0, width, height);
                        this.renderer.render(this.scene, this.player1.camera);
                     }
                 } else { 
                     // Multi-player split-screen
                     const halfWidth = Math.floor(width / 2);
                     
                     // P1 (Left)
                     if (this.player1) {
                        this.renderer.setViewport(0, 0, halfWidth, height);
                        this.renderer.setScissor(0, 0, halfWidth, height);
                        this.renderer.render(this.scene, this.player1.camera);
                     }
                     
                     // P2 (Right)
                     if (this.player2) {
                        this.renderer.setViewport(halfWidth, 0, width - halfWidth, height);
                        this.renderer.setScissor(halfWidth, 0, width - halfWidth, height);
                        this.renderer.render(this.scene, this.player2.camera);
                     }
                 }
             }
         }

         // --- Window Resize ---
         onWindowResize() {
             const width = window.innerWidth;
             const height = window.innerHeight;
          
             this.renderer.setSize(width, height);
             
             // Top Down Camera
             this.topDownCamera.aspect = width / height;
             this.topDownCamera.updateProjectionMatrix();
             
             // Player Follow Cameras
             const aspect = (this.gameMode === 'multi' && this.cameraStyle === 'follow')
                ? (width / 2) / height  // Split-screen aspect
                : width / height;       // Full-screen aspect
             
             if (this.player1) {
                this.player1.camera.aspect = aspect;
                this.player1.camera.updateProjectionMatrix();
             }
             if (this.player2) {
                this.player2.camera.aspect = aspect;
                this.player2.camera.updateProjectionMatrix();
             }
          
             // Touch Joystick
             if (this.inputMode === 'touch' && this.joystick) {
                 this.joystick.rect = this.joystick.area.getBoundingClientRect();
                 this.joystick.radius = this.joystick.rect.width / 2;
                 this.joystick.center = {
                     x: this.joystick.rect.left + this.joystick.radius,
                     y: this.joystick.rect.top + this.joystick.radius
                 };
             }
         }
     }
  
     // --- Start the application ---
     const app = new CharacterController();

 </script>
</body>
</html>

